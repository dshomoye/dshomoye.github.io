{"componentChunkName":"component---src-templates-blog-post-js","path":"/observables-hard-easy/","result":{"data":{"site":{"siteMetadata":{"title":"Damola's blog"}},"markdownRemark":{"id":"34d77c3e-ff7f-5e69-96ab-34f2062aaa43","excerpt":"Observables (ReactiveX/Observer pattern) seem to be showing up everywhere I look. Or maybe I have just been looking for it. Either way. I’ve felt like I needed…","htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Observables (ReactiveX/Observer pattern) seem to be showing up everywhere I look. Or maybe I have just been looking for it. Either way. I’ve felt like I needed to learn to use them. Even though I haven’t had a problem requiring Observables. Well, I guess not even really knowing how it worked meant I had no idea when I "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"should"}]},{"type":"text","value":" opt for it. So I did the next best thing: I shoe-horned it into a problem I had. And now that I’m through with it, I have a grasp of observables enough that I wanted to write down the process. For posterity. This will focus on rxjs (the Reactive library for JS) but the Observable pattern is implemented in a lot of major languages, "},{"type":"element","tagName":"a","properties":{"href":"http://reactivex.io/"},"children":[{"type":"text","value":"see here"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The real problem that led me down the Observable rabbit hole: While working on the revamp from python to JS of my LastFM based project (💀 RIP. Cause of death: needlessly complicated code). I needed to make 0-100s of API call to LastFM, to pull in all of the historical data that any user scrobbled to the service. This only matters for the first run per user but I still had to deal with it; Now I wanted to deploy this app to Vercel. It’s free for pet projects! But Vercel only provides serverless functions, so I had to design the “API calling” workflow around a serverless API that cannot run for more than 10s. The set up I wanted to create is a portal of some sort that shows the progress of the download (5%, 10% …). The actual pulling and saving to the database process have to happen on the backend (API keys and whatnot). But because of the serverless max run time, I definitely can’t make 100 calls in 10s."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"So, I came up with a not-so-pretty solution. I have an endpoint that specifies how many API calls (pages) need to be made to get all the latest scrobbles. And for each page, the UI calls the backend to request a “pull” for that specific page. So instead of invoking the backend function to pull all the data at once - which will timeout. I call the backend n+1 times, (n=number of pages). Invocations are “cheaper” than run times. And the part that needs Observables? Well, it turns out showing the progress of the download is harder than it seems.\nAnd "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"this"}]},{"type":"text","value":" is where Obsevables shine. In fact the table on the "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"rxjs"}]},{"type":"text","value":" page for observables "},{"type":"element","tagName":"a","properties":{"href":"https://rxjs-dev.firebaseapp.com/guide/observable"},"children":[{"type":"text","value":"hints at it"}]},{"type":"text","value":" - observables are the solution to the “multiple promises” scenario. You have a bunch (or infinite) number of promises and want to receive the result when any of them resolve, and keep receiving the result until exhausted.\nI was surprised this is not a very straightforward issue to solve natively in JavaScript. But, "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Promise"}]},{"type":"text","value":" only has "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":".all()"}]},{"type":"text","value":" and "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":".allSettled()"}]},{"type":"text","value":" - they both wait for "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"all"}]},{"type":"text","value":" "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"[]Promise"}]},{"type":"text","value":" to resolve before resolving themselves. "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"all()"}]},{"type":"text","value":" even exits on the first error!\nWhereas with an observable, you can dispatch multiple async calls, subscribe, and then listen for each resolved/emitted/errored value in a function.\nThis is the implementation I came up with:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"deckgo-highlight-code","properties":{"language":"javascript","theme":"one-dark"},"children":[{"type":"text","value":"\n          "},{"type":"element","tagName":"code","properties":{"slot":"code"},"children":[{"type":"text","value":"export function saveScrobbles(username, totalPages, fromTime) {\n  let currentPage = totalPages;\n  const promises = [];\n  while (currentPage > 0) {\n    const p = fetch(`/api/scrobbles/${username}`, {...});\n    promises.push(p);\n    currentPage -= 1;\n  }\n  return from(promises).pipe(mergeAll());\n}"}]},{"type":"text","value":"\n        "}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"from()"}]},{"type":"text","value":" is an "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"rxjs"}]},{"type":"text","value":" function for converting values "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"and"}]},{"type":"text","value":" promises to observables;"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"pipe()"}]},{"type":"text","value":" is a sort of helper function, for easily chaining operators. So if a, b, and c are operators that need to be applied to result of an observable o$, and they need to be applied in the order c(b(a(x))). this can expressed in a pipe as "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":".pipe(a(), b(), c())"}]},{"type":"text","value":" where each function gets the result of the preceding function call. "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"rxjs"}]},{"type":"text","value":" has a "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"lot"}]},{"type":"text","value":" of operators, infact, that’s the "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"real"}]},{"type":"text","value":" sell of the project "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://rxjs-dev.firebaseapp.com/guide/overview"},"children":[{"type":"text","value":"Think of RxJS as Lodash for events"}]}]},{"type":"text","value":". It facilitates writing in a functional way; you can "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"pipe"}]},{"type":"text","value":" a "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"filter"}]},{"type":"text","value":" into a "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"debounce"}]},{"type":"text","value":" into a "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"map"}]},{"type":"text","value":" into "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"merge"}]},{"type":"text","value":" quite easily."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"saveScrobbles"}]},{"type":"text","value":" function returns an observable, and the subscription looks like:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"deckgo-highlight-code","properties":{"language":"javascript","theme":"one-dark"},"children":[{"type":"text","value":"\n          "},{"type":"element","tagName":"code","properties":{"slot":"code"},"children":[{"type":"text","value":"    const pages$ = saveScrobbles(username, totalPages, from);\n\t  ...\n    pages$.subscribe({\n      next: () => {\n        setCompletedPages((prev) => prev + 1);\n      },\n      complete: () => {...},\n    });"}]},{"type":"text","value":"\n        "}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Once an observable is called with"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":".subscribe()"}]},{"type":"text","value":", the "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"next()"}]},{"type":"text","value":" function is called every time a new value is returned. Technically, the signature is "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"next(value)"}]},{"type":"text","value":" but I didn’t use the returned value here.\nThe "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"complete"}]},{"type":"text","value":" function is called when all values have been emitted. This is equivalent to what you would normally have access to when using "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Promise.all()"}]},{"type":"text","value":" or "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Promise.allSettled()"}]},{"type":"text","value":".\nThere’s also an "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"error"}]},{"type":"text","value":" function whenever an error occurs while getting a value - not used here.\nOne very important property of observables that I am not even taking advantage of here, is that there can be multiple subscribers. This is another part of what makes observables powerful. It’s not possible to "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Promise.all()"}]},{"type":"text","value":" more than once. But "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"page$.subscribe"}]},{"type":"text","value":" can be called multiple times from different places (and the "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"next"}]},{"type":"text","value":", "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"error"}]},{"type":"text","value":" and "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"complete"}]},{"type":"text","value":" will be called individually)."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"So, "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"completedPages"}]},{"type":"text","value":" is the number of pages updated, and since there’s already access to the total number of pages. It’s trivial to show the percentage completed.\nAnd that’s it, a very simple to use Reactivity/Observables.\nI should reiterate this is barely scratching the surface of what’s possible with observables, more a basic intro for "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"understanding"}]},{"type":"text","value":" what they are.\nAlso, I know there are better solutions to this problem. For one, a regular web-server can make all the calls and have an endpoint that gets polled to get the progress state. Or, using a Websocket for instant progress pings - I think this is preferable since it will avoid the polling logic - which could lead to a lot of GET calls as well."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Some good references:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Netflix Engineering video "},{"type":"element","tagName":"a","properties":{"href":"https://www.youtube.com/watch?v=AslncyG8whg"},"children":[{"type":"text","value":"video"}]},{"type":"text","value":" on rxjs."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://rxjs-dev.firebaseapp.com/guide/overview"},"children":[{"type":"text","value":"rxjs"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"http://reactivex.io/intro.html"},"children":[{"type":"text","value":"ReactiveX - Intro"}]}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}},"frontmatter":{"title":"Learning Observables the hard (easy) way","date":"October 22, 2020","description":"ReactiveX is the new black.","gallerySources":null,"lastUpdated":null,"tags":["technology"]},"timeToRead":4}},"pageContext":{"slug":"/observables-hard-easy/","previous":{"parent":{"name":"index"},"fields":{"slug":"/gatsby-web-push-notifications/"},"frontmatter":{"title":"Web Push Notifications in Gatsby."}},"next":{"parent":{"name":"index"},"fields":{"slug":"/trying-rust-lang/"},"frontmatter":{"title":"Testing the waters - Thoughts on Rust."}}}},"staticQueryHashes":["139983731","63159454"]}