---
title: "Web Push Notifications in Gatsby."
date: "2020-03-15"
description: "How I added notifications to this Gatsby blog using Service workers, Netlify functions and FaunaDB"
bannerImage: "media/gatsby-web-push-notifications/notification-request.gif"
lastUpdated: "2020-03-22"
---

Push notifications are an excellent feature in web applications (when they‚Äôre not abused). It lets web apps send notifications to devices, even if the website is closed, as if the web app was natively installed.
I went from thinking implementing push notifications in Gatsby would be easy (after all, enabling offline support only took adding a plugin) - to thinking it would be hopelessly difficult, after searching for an offline plugin, not finding one, seeing [this issue](https://github.com/gatsbyjs/gatsby/issues/11140)‚ßâ and thinking I would have to rewrite a new service worker - to realizing it's doable. All I had to do was _append_ to the service-worker that is generated by [`gatbsy-plugin-offline`](https://www.gatsbyjs.org/packages/gatsby-plugin-offline/)‚ßâ.

The option I needed (and missed for a long time) is `appendScript` which points to a javascript file that gets added to the service worker code. So, you can keep the full offline feature the plugin provides and just build on top of that.
I used this [guide](https://developers.google.com/web/fundamentals/push-notifications)‚ßâ to get a better understanding of implementing push notifications. It should be a good reference especially if deviating from my implementation.

> This post is not a step-by-step guide and assumes comfort with a Gatsby project, installing npm packages and so on.

---

Here is everything I created to get push notifications running,

- A React component that lets users control subscription.
- FaunaDB database for storing subscriptions (add/delete)
- A Netlify function that listens to new subscriptions (and unsubscribes ) and another for sending push notification to subscribers.
- Service worker that creates a notification on the user‚Äôs device.

---

## Push notification React component

Even though implementing push notifications is (probably equally) a backend and front end endeavor, I ended up spending a lot of time creating this UI component. If you have read my previous posts, you‚Äôll know that I strongly oppose dark patterns (well, I suppose _most_ people do). I definitely wanted to do it right, so it was important to make unsubscribing as easy as subscribing - and I took my time to make sure I accomplished this.
The component itself is a button that lies in the footer of the page. The basic flow when the button is clicked is:

- If the browser supports push notifications: - request permission to send notifications, if permitted: - create a new subscription and send the subscription data to the backend - change the button to allow the user to unsubscribe. - if request not permitted, show an error alert that
- if the browser doesn‚Äôt support push notifications then nothing shows up.

On Safari or any other browser that does not support the Push API, the component returns `null` and nothing renders. There‚Äôs one caveat that in Gatsby, ‚Äúwindow‚Äù isn‚Äôt defined at build time (build runs in node) so I had to wrap this check inside another check like so:

```js
//PushNotification.js
...
if (typeof window !== `undefined`) {
  if ("PushManager" in window) {
    return true
  }
}
...
```

Subscribing and unsubscribing simply requires making calls to : `swRegistration.pushManager.subscribe` and `subscription.unsubscribe` respectively. Once subscribed, the browser returns a subscription object containing the endpoint url and all extra data required to send encrypted notifications to that url.
And saving the subscription is a `POST` call to the subscription endpoint. I will go over that in the section for the Netlify functions.

To persist subscription state (closed tab or even browser), a flag gets stored in `localStorage` to specify wether the user is subscribed or not. The value of the flag is used to determine the React state of the subscription button. I used a flag instead of storing subscription information to ensure I was storing the least amount of data (requesting a subscription from the browser returns the same subscription endpoint url if there's an existing one, so there's no need to store that url).

For notifying on the status of the subscription, I decided to use `react-notify-toast`. It‚Äôs very basic and does exactly what its name suggest. This creates _toast notifications_ that show up in the web page itself (so a DOM element), not browser notifications, a bit confusing, I know. It looks something like this:

<media-box src="media/gatsby-web-push-notifications/toast.gif" name="Toast notification."></media-box>

## FaunaDB

I chose FaunaDB because it was one of the few serverless providers I could find that I knew would be truly free without resorting to dynamo of Firebase (not that there‚Äôs anything wrong with them I just didn't want to set it up).
As an additional bonus, it has a GraphQL api, so it fits right into the Gatsby ecosystem which already uses it.

Because FaunaDB is Serverless, creating resolvers (handling queries and sending the response) for GraphQL queries is simpler than in an `Apollo` or REST backend. In fact, the whole idea is that you don‚Äôt need to write resolvers, with FaunaDB all you have to do is to create a GraphQL schema and basic resolvers are automatically created. So every new GraphQL `type` can automatically be queried, updated or deleted.

Each new item is assigned an `id` that can be used as reference for updating/deleting. This would have sufficed here but I wanted to use the `endpoint` (url notification data is sent to) for each push subscription to be the identifier instead of the id assigned by FaunaDB. This was because I wanted it to be easy to unsubscribe from the frontend and also be indepenent of the backend architecture - if I decided to migrate to a different database, the subscription endpoints urls would remain and ids will change (or not exist)

The subscription type and mutations definitions in GraphQL :

`embed:functions/graphql/schema.graphql`

I just had to upload this file to FaunaDB and everything was automatically created, how nice is that!

Creating `delete_endpoint` resolver led me down an unfortunate hole of learning to write FQL (Fauna Query Language, not to be confused with FQL ‚Äî Facebook Query Language ü§∑üèæ‚Äç‚ôÇÔ∏è).
This is the FQL code:

`embed:functions/graphql/delete_endpoint.fql`

All this is doing is fetching all subscriptions that match the provided endpoint (`Var("endpoint")`) storing its reference and deleting the item in the reference.

FQL isn‚Äôt the most straightforward language to learn and write, but it really opens up possibilities for customizing the database while still avoiding running a backend service. And that wraps up everything required to add and delete subscriptions on the backend.

## (Lambda Powered) Netlify Functions

I created two Netlify functions ([push-subscription](https://github.com/dshomoye/dshomoye.github.io/blob/gatsby/functions/push-subscription.js)‚ßâ and [`push-notification`](https://github.com/dshomoye/dshomoye.github.io/blob/gatsby/functions/push-notification.js)‚ßâ
). Netlify functions are basically AWS Lambda functions so if you have experience with that, it‚Äôs the same. Create an event handler for HTTP requests -> Process the event -> Send a response.

For receiving new subscriptions and deleting existing ones, the only dependency I had was `got`, a really nice fetch-like node library. And it worked out well enough until I ran into problems escaping quotes in the GraphQL query which contained `JSON.stringify()` string of the subscription object. So I added a package called `graph-request` which made things easier.
So all that had to be done was respond to POST and DELETE requests and then sending the appropriate query to the FaunaDB GraphQL endpoint.
Here is what the handler for creating new subscriptions looks like:

```js
//push-subscription.js
...
exports.handler = async function(event) {
  const method = event.httpMethod
  switch (method) {
    case "POST":
      try {
        const eventData = JSON.parse(event.body)
        const { endpoint, data } = eventData
        const addResponse = await addSubscription(endpoint, data)
        console.log("New Subscription added for: ", endpoint)
        return addResponse
      } catch (error) {
        console.error("Error saving subscription ", error)
        return {
          statusCode: 400,
          body: `{"error": "Unable to process"}`,
        }
      }
...
```

For sending notifications I created a separate Netlify function push-notification.js. There is an additional package `web-push` that makes the call to a subscription endpoint (and creates all the necessary encryption using the private key) which then triggers the notification on the user's device. This Netlify function runs a GraphQL query to get all subscriptions and sends a web push to each endpoint, the rest of the data required by `web-push` is stored in the `subscriptionData` field returned from the database.

## Service Worker

Even though the service worker creates the notification that the user sees, it actually turned out to be the simplest piece of this puzzle. I admittedly only implemented creating notifications with a customized `title` and `message`. However, adding support for custom icons, urls (right now, clicking the notification just goes to the homepage of the blog) and adding tags would not be too complicated.

`self.addEventListener(‚Äúnotificationclick‚Äù, function(event))` handles a new notification sent from the backend, this listener is constantly running in the background even when the site is closed.
`self.registration.showNotification(title, options)` sends a new notification.
The resulting service worker code:

`embed:src/notification-sw.js`

And then I updated `gatsby-config` to include the custom service worker code, like so:

```js
//gatsby-config.js
...
    {
      resolve: `gatsby-plugin-offline`,
      options: {
        appendScript: require.resolve(`${__dirname}/src/notification-sw.js`),
      },
    },
...
```

And that‚Äôs it!

---
I send notifications using Postman right now. I considered building out a UI to call the Netlify function I created, but I only need to send a _title_ and a _message_, it was too much effort for too little gain. 

## References

Here are some links that will should hopefully help with getting started and might have been missed in the article:

- Web Push Notifications [tutorial](https://developers.google.com/web/fundamentals/push-notifications).
- [Offline plugin for Gatsby](https://www.gatsbyjs.org/packages/gatsby-plugin-offline/) - this plugin is not required but adding offline capability is very beneficial, the plugin also automatically sets up the service worker.
- [FaunaDB](https://dashboard.fauna.com/).
- [web-push](https://www.npmjs.com/package/web-push) npm package.
- Code is public, you can view the full source [here](https://github.com/dshomoye/dshomoye.github.io).
