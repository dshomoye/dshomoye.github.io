---
title: "Web Push Notifications in Gatsby."
date: "2020-03-15"
description: "How I added notifications to this Gatsby blog using service workers and Netlify functions."
bannerImage: "notification-request.gif"
lastUpdated: "2021-02-15"
tags:
  - "technology"
---

> Some sections of this post have been edited since original posting.

Push notifications are an awesome addition to the web (when they‚Äôre not abused). It lets web apps send notifications to devices as if they're natively installed apps! Gatsby on the other hand has turned building static sites into a pretty impressive ecosystem. Bringing push notifications into Gatsby is a natural next step for any modern site. You probably already know all this, if you're here reading this and just want to know _how_, so I'll jump right into it.

I went from thinking implementing push notifications in Gatsby would be easy (after all, enabling offline support only took adding a plugin) - to thinking it would be hopelessly difficult, after searching for an offline plugin, not finding one, seeing [this issue](https://github.com/gatsbyjs/gatsby/issues/11140)‚ßâ and thinking I would have to rewrite a new service worker - to realizing it's actually doable. All I had to do was _append_ to the service-worker that is generated by [`gatbsy-plugin-offline`](https://www.gatsbyjs.org/packages/gatsby-plugin-offline/)‚ßâ. This was an "ah-ha" üí° moment for me.

The option I needed (and missed for a long time) is `appendScript` which points to a javascript file that gets added to the service worker code. So, you can keep the full offline feature the plugin provides and just build on top of that.
I used this [guide](https://developers.google.com/web/fundamentals/push-notifications)‚ßâ to get a better understanding of implementing push notifications. I highly recommend atleast skimming through that as building out a push notification system involves an end-to-end understanding of the process.

> This post is not a step-by-step guide and assumes comfort with a Gatsby; and a project that's already set up including plugin(s) referenced. For a full look-through of the code, there's a link to this site's source at the [end of the post](#references).

---

Here is everything I created to get push notifications running,

- A React component that lets users control subscription (the button at the bottom of every page on this blog).
- Database for storing subscriptions (add/get/delete).
- A Netlify function that listens for subscriptions/unsubscriptions and another for sending push notification to subscribers.
- Service worker that listens for and sends notifications to the user‚Äôs device.

---

## Push notification React component

Even though implementing push notifications is (probably equally) a backend and front end endeavor, I ended up spending a lot of time creating this UI component. If you have read my previous posts, you‚Äôll know that I strongly oppose dark patterns (well, I suppose _most_ people do). I definitely wanted to do it right, so it was important to make unsubscribing as easy as subscribing - and I took my time to make sure I accomplished this.
The component itself is a button that lies in the footer of the page. The basic flow when the button is clicked is:

- If the browser supports push notifications: - request permission to send notifications, if permitted: - create a new subscription and send the subscription data to the backend - change the button to allow the user to unsubscribe. - if request not permitted, show an error alert.
- if the browser doesn‚Äôt support push notifications, then nothing shows up.

On Safari or any other browser that does not support the Push API, the component returns `null` and nothing renders. There‚Äôs one caveat that in Gatsby, ‚Äúwindow‚Äù isn‚Äôt defined at build time (build runs in node) so I had to wrap this check inside another check like so:

```js
//PushNotification.js
...
if (typeof window !== `undefined`) {
  if ("PushManager" in window) {
    return true
  }
}
...
```

Subscribing and unsubscribing simply requires making calls to : `swRegistration.pushManager.subscribe` and `subscription.unsubscribe` respectively. Once subscribed, the browser returns a subscription object containing the endpoint url and all extra data required to send encrypted notifications to that url.
And saving the subscription is a `POST` call to the subscription endpoint. I will go over that in the section for the Netlify functions.

To persist subscription state (closed tab or even browser), a flag gets stored in `localStorage` to specify wether the user is subscribed or not. The value of the flag is used to determine the React state of the subscription button. I used a flag instead of storing subscription information to ensure I was storing the least amount of data (requesting a subscription from the browser returns the same subscription endpoint url if there's an existing one, so there's no need to store that url).

For notifying on the status of the subscription, I decided to use `react-notify-toast`. It‚Äôs very basic and does exactly what its name suggest. This creates _toast notifications_ that show up in the web page itself (so a DOM element), not browser notifications, a bit confusing, I know. It looks something like this:

<media-box src="media/gatsby-web-push-notifications/toast.gif" name="Toast notification."></media-box>

> Update (June-06-2020): After realizing the actual experience of subscribing to push notifications and getting a toast but _not_ a push notification is a little jarring, I have now made updates that will send an actual push notification to the user's browser to confirm subscription. I'd avoided this to not annoy people with unnecessary pings, but it definitely fits in this scenario. The toasts described above are **still** shown since I need a way to provide feedback push subscription status even if push is not available.

## Database

There are many options for a database for storing subscriptions. I used FaunaDB and it worked out fine. I didn't want to keep working with FQL (Fauna's query language):
I just recently migrated to Hasura at [hasura.io](https://hasura.io). This is slightly less straightfoward to set up (hasura is fronting a postgres db running on heroku).
I do find it easier to work with hasua's UI and graphql engine (for me) than FQL.

Some options to consider for a database:

- FaunaDB
- Hasura + heroku
- Google cloud firestore
- dynamodb

Really, any kind of persistent data store that can satisfy the following will suffice:

- Storing the subscription data,
- fetching all subscriptions (when sending notifications)
- pulling an individual subscription by its id.

The _shape_ (JavaScript object) of the subscriptions is:

```js
{
  endpoint: '<...>',
  expirationTime: null,
  keys: {
    p256dh: '<...>',
    auth: '<...>'
  }
}
```

The subscription is stored as-is. This is easy since postgres supports json/jsonb.
Storing a json string is also valid. This is what I was doing with FaunaDB.

The `endpoint` is always unique for each subscription (per browser); it's perfect as the primary key/id.
A unique ID is necessary for finding and deleting subscriptions when a user unsubscribes. In my case, the table storing subscriptions essentially has two columns - one for the subscription data itself (json) and a column for the endpoint.

## (Lambda Powered) Netlify Functions

I created two Netlify functions ([push-subscription](https://github.com/dshomoye/dshomoye.github.io/blob/gatsby/functions/push-subscription.js)‚ßâ and [push-notification](https://github.com/dshomoye/dshomoye.github.io/blob/gatsby/functions/push-notification.js)‚ßâ
). Netlify functions are basically AWS Lambda functions so if you have experience with that, it‚Äôs the same. Create an event handler for HTTP requests -> Process the event -> Send a response.

I use a package called `graph-request` for making graphql requests to hasura, same as I did with Fauna.
So all I needed was respond to POST and DELETE requests and then sending the appropriate query to the GraphQL endpoint.
Here is what the handler for creating new subscriptions looks like:

```js
//push-subscription.js
...
exports.handler = async function(event) {
  const method = event.httpMethod
  switch (method) {
    case "POST":
      try {
        const eventData = JSON.parse(event.body)
        const { endpoint, data } = eventData
        const addResponse = await addSubscription(endpoint, data)
        console.log("New Subscription added for: ", endpoint)
        return addResponse
      } catch (error) {
        console.error("Error saving subscription ", error)
        return {
          statusCode: 400,
          body: `{"error": "Unable to process"}`,
        }
      }
...
```

For sending notifications I created a separate Netlify function `push-notification.js`. There is an additional package `web-push` that makes the call to a subscription endpoint (and creates all the necessary encryption using the private key) which then triggers the notification on the user's device. This Netlify function runs a GraphQL query to get all subscriptions and sends a web push to each endpoint, the rest of the data required by `web-push` is stored in the `subscription` field returned from the database.

## Service Worker

Even though the service worker creates the notification that the user sees, it actually turned out to be the simplest piece of this puzzle. I admittedly only implemented creating notifications with a customized `title` and `message`. However, adding support for custom icons, urls (right now, clicking the notification just goes to the homepage of the blog) and adding tags would not be too complicated.

`self.addEventListener(‚Äúnotificationclick‚Äù, function(event))` handles a new notification sent from the backend, this listener is constantly running in the background even when the site is closed.
`self.registration.showNotification(title, options)` sends a new notification.
The resulting service worker code:

`embed:src/notification-sw.js`

And then I updated `gatsby-config` to include the custom service worker code, like so:

```js
//gatsby-config.js
...
    {
      resolve: `gatsby-plugin-offline`,
      options: {
        appendScript: require.resolve(`${__dirname}/src/notification-sw.js`),
      },
    },
...
```

And that‚Äôs it!

---

I send notifications using Postman right now. I considered building out a UI to call the Netlify function I created, but I only need to send a _title_ and a _message_, it was too much effort for too little gain.

## References

Here are some links that will should hopefully help with getting started and might have been missed in the article:

- Web Push Notifications [tutorial](https://developers.google.com/web/fundamentals/push-notifications).
- [Offline plugin for Gatsby](https://www.gatsbyjs.org/packages/gatsby-plugin-offline/) - this plugin is not required but adding offline capability is very beneficial, the plugin also automatically sets up the service worker.
- [web-push](https://www.npmjs.com/package/web-push) npm package.
- Code is public, you can view the full source [here](https://github.com/dshomoye/dshomoye.github.io) - and feel free to star/follow or drop a note.
