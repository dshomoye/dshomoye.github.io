---
title: "Web Push Notifications in a Gatsby site."
date: "2020-03-15"
description: "How I added notifications to this Gatsby blog using Service workers, Netlify functions and FaunaDB"
bannerImage: "media/gatsby-web-push-notifications/pwa.png"
---


Push notifications are an excellent feature in web applications (when they‚Äôre not abused). It lets web apps send notifications to devices, even if the website is closed, as if the web app was natively installed.
I went from thinking implementing push notifications in Gatsby would be easy (after all, enabling offline support only took adding a plugin) - to thinking it would be hopelessly difficult, after searching for an offline plugin and not finding one, and seeing [this issue](https://github.com/gatsbyjs/gatsby/issues/11140) ‚ßâ and thinking I would have to rewrite a new service worker - to realizing it's doable. All I had to do was *append* to the service-worker that is generated by [`gatbsy-plugin-offline`](https://www.gatsbyjs.org/packages/gatsby-plugin-offline/)‚ßâ.
The key option here (which I missed for a long time) is `appendScript` which points to a javascript file that gets added to the service worker code. So, you can keep the full offline feature the plugin provides and just build on top of that.
I used this [guide](https://developers.google.com/web/fundamentals/push-notifications)‚ßâ to get a better understanding of implementing push notifications. It should be a good reference especially if deviating from my implementation.

---

Here are the main components I had to build in order to get the notification system running,

- A React component that allows that controls subscriptions.
- FaunaDB database for storing subscriptions (add/delete)
- A Netlify function that listens to new subscriptions (and unsubscribes ) and  for sending push notification to all subscribers.
- Service worker code that listens to *push* events and creates a notification on the user‚Äôs device.

---

## Push notification React component
Even though implementing push notifications is equally a backend and front end endeavor, I ended up spending a lot of time creating this one component. If you have read my previous posts, you‚Äôll know that I am very against dark patterns. I definitely wanted to do it right, so it was important to make unsubscribing as easy as subscribing. 
The component itself is a button that lies in the footer of the page. The basic flow when the button is clicked is:

- If the browser supports push notifications:
	- request permission to send notifications, if permitted:
		- create a new subscription and send the subscription to the backend
		- change the button to allow the user to unsubscribe.
	- if request not permitted, show an error alert that 
- if the browser doesn‚Äôt support push notifications then nothing shows up. 


On Safari or any other browser that does not support the Push API, in which case, the component returns `null`  and nothing renders. There‚Äôs one caveat that in Gatsby, ‚Äúwindow‚Äù isn‚Äôt defined at build time (build runs in node) so I had to wrap this check inside another check like so:

```js
//PushNotification.js
...
if (typeof window !== `undefined`) {
  if ("PushManager" in window) {
    return true
  }
}
...
```

Subscribing and unsubscribing simply requires making calls to : ` swRegistration.pushManager.subscribe` and `swRegistration.pushManager.getSubscription` respectively.
And saving the subscription is a `POST` call to the subscription endpoint. I will go over that in the section for the Netlify functions. 
For notifying on the status of the subscription, I decided to use `react-notify-toast`. It‚Äôs very basic and does exactly what its name suggest. This creates _toast notifications_ that show up in the web page itself (so just UI elements), and not browser notifications, a bit confusing, I know. It looks something like this:

<media-box src="media/gatsby-web-push-notifications/toast.gif" name="Toast notification."></media-box>

## FaunaDB
I chose FaunaDB because it was one of the few serverless providers I could find that I knew would be truly free without setting up dynamo on AWS or dealing with Firebase (not that there‚Äôs anything wrong with them I just wanted to set it up). 
As an additional bonus, they have a GraphQL api, so it fits right into the Gatsby ecosystem which already uses it. Being that the FaunaDB is Serverless, creating resolvers (handling queries and sending the response) for the GraphQL queries is a less straightforward than in an `Apollo` backend. In fact, the whole idea is you don‚Äôt need to write resolves, with FaunaDB all you have to is to create a GraphQL schema and basic resolvers are automatically created. So every new GraphQL `type` can automatically be queried, updated or deleted. 
Each new item gets assigned an `id` that can be used to reference for updating/deleting down the line. This would have sufficed for my use case but I wanted to use the `endpoint` for each push subscription to be the identifier instead of id assigned by FaunaDB. This was because I wanted it to be easy to unsubscribe from the frontend without having to know about backend architecture.
The subscription type and mutations are:

`embed:functions/graphql/schema.graphql`

Creating  `delete_endpoint` resolver led me down an unfortunate hole of learning to write FQL (Fauna Query Language, not to be confused with FQL ‚Äî Facebook Query Language ü§∑üèæ‚Äç‚ôÇÔ∏è). 
This is the FQL code:

`embed:functions/graphql/delete_endpoint.fql`

All this is doing is fetching all subscriptions that match the provided endpoint (`Var("endpoint")`) storing its reference and deleting the item in the reference.

FQL isn‚Äôt the most straightforward language to learn and write, but it really opens more possibilities for customizing the databsae while still avoiding running a backend service.  And that wraps up everything required to add and delete subscriptions on the backend.

## (Lambda Powered) Netlify Functions
I created two Netlify functions ([push-subscription](https://github.com/dshomoye/dshomoye.github.io/blob/gatsby/functions/push-subscription.js)‚ßâ and [`push-notification`](https://github.com/dshomoye/dshomoye.github.io/blob/gatsby/functions/push-notification.js)‚ßâ
). Netlify functions are basically AWS Lambda functions so if you have experience with that, it‚Äôs fairly straightforward. Create an event handler for HTTP requests -> Process the event -> Send a response.
For receiving new subscriptions and deleting existing ones, the only dependency I had was `got`, a well designed fetch-like node library. And it worked out nicely until I ran into problems escaping quotes in the GraphQL query which contained `JSON.stringify()` string of the subscription object. So I added a package called `graph-request` which made things easier. 
So all that had to be done was respond to POST and DELETE requests. 
For sending notifications, there is an additional package `web-push`  that actually makes the call to all subscription endpoints. This function runs a GraphQL query to get all subscriptions and sends a web push to each endpoint, the rest of the data required by `web-push` is stored in the `subscriptionData` field returned from the database.

## Service Worker
Even though the service worker handles the notification sending, it actually turned out to be the simplest piece of this puzzle. I admittedly only implemented creating notifications with a customized `title` and `message`. However, adding support for custom icons, urls (right now, clicking the notification just goes to the homepage of the blog) and adding tags would not be too complicated. 
`self.addEventListener(‚Äúnotificationclick‚Äù, function(event))` handles a new notification sent from the backend, this listener is constantly running in the background even when the site is closed.
`self.registration.showNotification(title, options)` sends a new notification. 
The resulting service worker code:

`embed:src/notification-sw.js`

And then I updated `gatsby-config` to include the custom service worker code, like so:
```js
//gatsby-config.js
...
    {
      resolve: `gatsby-plugin-offline`,
      options: {
        appendScript: require.resolve(`${__dirname}/src/notification-sw.js`),
      },
    },
...
```

And that‚Äôs it!

## References
Here are some links that will should hopefully help with getting started and might have been missed in the article:
- Web Push Notifications [tutorial](https://developers.google.com/web/fundamentals/push-notifications).
- [Offline plugin for Gatsby](https://www.gatsbyjs.org/packages/gatsby-plugin-offline/) - this plugin is not required but adding offline capability is very beneficial, the plugin also automatically sets up the service worker.
- [FaunaDB](https://dashboard.fauna.com/).
- [web-push](https://www.npmjs.com/package/web-push) npm package.
- Code is public, you can view the full source [here](https://github.com/dshomoye/dshomoye.github.io).

